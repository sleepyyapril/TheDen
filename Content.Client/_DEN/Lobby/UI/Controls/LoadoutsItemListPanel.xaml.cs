// SPDX-FileCopyrightText: 2025 portfiend
// SPDX-FileCopyrightText: 2025 sleepyyapril
//
// SPDX-License-Identifier: MPL-2.0

using System.Diagnostics;
using System.Linq;
using Content.Client._DEN.Customization.Systems;
using Content.Client._DEN.Lobby.UI.Loadouts;
using Content.Client.Administration.UI;
using Content.Client.Lobby;
using Content.Client.Players.PlayTimeTracking;
using Content.Client.Resources;
using Content.Shared.CCVar;
using Content.Shared.Clothing.Components;
using Content.Shared.Clothing.Loadouts.Prototypes;
using Content.Shared.Clothing.Loadouts.Systems;
using Content.Shared.Preferences;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.ResourceManagement;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Configuration;
using Robust.Shared.Prototypes;

namespace Content.Client._DEN.Lobby.UI.Controls;

/// <summary>
///     This panel contains all loadout item buttons, the buttons you actually click on
///     to toggle the loadout preferences on/off. It also handles searching, removing
///     unusable loadouts, and managing the wearable/usable states of each button.
/// </summary>
/// <remarks>
///     Due to having a list of all loadout buttons, this panel acts as the de-facto
///     "source of truth" for what loadouts exist. That's why this class, and LoadoutItemButton
///     are so complex. In the future I would like to separate these concerns a little better.
/// </remarks>
[GenerateTypedNameReferences]
public sealed partial class LoadoutsItemListPanel : BoxContainer
{
    [Dependency] private readonly IConfigurationManager _configuration = default!;
    [Dependency] private readonly IEntityManager _entity = default!;
    [Dependency] private readonly IPrototypeManager _prototype = default!;
    [Dependency] private readonly IResourceCache _resourceCache = default!;
    private readonly CharacterRequirementsSystem _characterRequirements;

    /// <summary>
    ///     Fired when points remaining are recalculated.
    /// </summary>
    public event Action<int>? OnPointsUpdaated;

    /// <summary>
    ///     Fired when a loadout preference changes.
    /// </summary>
    public event Action<LoadoutPreference>? OnPreferenceChanged;

    /// <summary>
    ///     Fired when a loadout item's "customize" button is clicked.
    /// </summary>
    public event Action<LoadoutPreference>? OnCustomizeToggled;

    /// <summary>
    ///     Fired when "remove unusable loadouts" is clicked and confirmed.
    /// </summary>
    public event Action? OnRemoveUnusableLoadouts;

    /// <summary>
    ///     Fired when a loadout item's "guidebook" button is clicked.
    /// </summary>
    public event Action<string>? OnOpenGuidebook;

    private const string CategoryNameFontPath = "/Fonts/NotoSans/NotoSans-Bold.ttf";
    private const string RemoveUnusableLocale = "humanoid-profile-editor-loadouts-remove-unusable-button";
    private const string RemoveUnusableParameter = "count";
    private const int CategoryNameFontSize = 16;
    private Font CategoryNameFont => _resourceCache.GetFont(CategoryNameFontPath, CategoryNameFontSize);

    private Dictionary<string, LoadoutPreference> _profilePreferenceLookup = new();
    private Dictionary<ProtoId<LoadoutCategoryPrototype>, BoxContainer> _categoryLists = new();
    private Dictionary<LoadoutPrototype, LoadoutItemButton> _loadoutButtons = new();
    private Dictionary<Button, ConfirmationData> _confirmationData = new();
    private ProtoId<LoadoutCategoryPrototype>? _currentCategory = null;

    /// <summary>
    ///     A list of all currently-requipped loadouts that are either unusable
    ///     or unwearable.
    /// </summary>
    public List<LoadoutPrototype> UnusableLoadouts => _loadoutButtons.Values
        .Where(b => b.Preference.Selected && (b.Unusable || b.Unwearable))
        .Select(b => b.Loadout)
        .ToList();

    private HumanoidCharacterProfile? _profile = null;
    private EntityUid? _characterDummy = null;
    private int MaxPoints => _configuration.GetCVar(CCVars.GameLoadoutsPoints);
    private int _points = 0;

    public LoadoutsItemListPanel()
    {
        IoCManager.InjectDependencies(this);
        RobustXamlLoader.Load(this);
        _characterRequirements = _entity.System<CharacterRequirementsSystem>();

        CategoryTitle.FontOverride = CategoryNameFont;

        var stopwatch = new Stopwatch();
        stopwatch.Start();

        try
        {
            PopulateLoadouts();
        }
        finally
        {
            stopwatch.Stop();
            Logger.GetSawmill("LoadoutsItemListPanel")
                .Debug($"All loadout items loaded in {stopwatch.Elapsed.TotalMilliseconds}ms");
        }

        SearchLineEdit.OnTextChanged += args => UpdateSearchFilter(args.Text);
        ClearSearchButton.OnPressed += _ => SearchLineEdit.SetText(string.Empty, invokeEvent: true);
        ShowUnusableButton.OnToggled += _ => UpdateButtonVisibility();
        RemoveUnusableButton.OnPressed += _ => RemoveUnusableLoadouts();
    }

    /// <summary>
    ///     Sets the current profile that this panel uses. This also updates the currently-selected
    ///     status of loadout buttons, recalculates how many points are being spent, and updates
    ///     the requirements for this panel.
    /// </summary>
    /// <remarks>
    ///     This function is HEAVY; it's pretty vital that this only gets called (at most) once in a
    ///     frame, because calling it twice will cause noticeable, unnecessary lag.
    /// </remarks>
    /// <param name="profile">The character profile to sync loadout states to.</param>
    public void SetProfile(HumanoidCharacterProfile? profile)
    {
        _profile = profile;
        _profilePreferenceLookup = _profile?.LoadoutPreferences
            .ToDictionary(lp => lp.LoadoutName)
            ?? new();

        RecalculatePoints();
        UpdatePreferences();
        UpdateRequirements();

        var unusable = UnusableLoadouts.Count();
        var removeUnusableText = Loc.GetString(RemoveUnusableLocale, (RemoveUnusableParameter, unusable));
        RemoveUnusableButton.Text = removeUnusableText;

        AdminUIHelpers.RemoveConfirm(RemoveUnusableButton, _confirmationData);
    }

    /// <summary>
    ///     Sets the character preview dummy the loadout tab will use.
    /// </summary>
    /// <remarks>
    ///     This is used for checking is a loadout can be worn by the current character, as
    ///     the dummy (ideally) should have the same inventory slots as the player species.
    /// </remarks>
    /// <param name="dummy">The dummy entity to use.</param>
    public void SetCharacterDummy(EntityUid? dummy)
    {
        _characterDummy = dummy;
    }

    /// <summary>
    ///     Sets the currently visible category panel for loadout items.
    /// </summary>
    /// <param name="category">ID of the category to make visible.</param>
    public void SetVisibleCategory(ProtoId<LoadoutCategoryPrototype>? category)
    {
        if (_currentCategory == category)
            return;

        var titleText = string.Empty;

        // Hide previous box
        if (_currentCategory != null
            && _categoryLists.TryGetValue(_currentCategory.Value, out var oldBox))
            oldBox.Visible = false;

        _currentCategory = category;

        // Show new box
        if (_currentCategory != null)
        {
            titleText = LoadoutsTab.GetCategoryName(_currentCategory.Value);
            if (_categoryLists.TryGetValue(_currentCategory.Value, out var listBox))
                listBox.Visible = true;
        }

        CategoryTitle.Text = titleText;
    }

    /// <summary>
    ///     Initializes all category boxes containing lists of loadout items.
    /// </summary>
    /// <param name="reset">When this is true, all categories/buttons will be deleted first.</param>
    public void PopulateLoadouts(bool reset = false)
    {
        if (reset)
        {
            CategoryContents.RemoveAllChildren();
            _categoryLists.Clear();
            _loadoutButtons.Clear();
        }

        var groups = _prototype.EnumeratePrototypes<LoadoutPrototype>()
            .OrderBy(l => l.ID)
            .GroupBy(l => l.Category);

        foreach (var group in groups)
        {
            var category = group.Key;

            if (!_categoryLists.TryGetValue(category, out var listBox))
            {
                listBox = CreateLoadoutListBox(category);
                CategoryContents.AddChild(listBox);
                _categoryLists.Add(category, listBox);
            }

            foreach (var loadout in group)
            {
                if (_loadoutButtons.TryGetValue(loadout, out var _))
                    continue;

                var button = new LoadoutItemButton(loadout,
                    _characterRequirements,
                    _configuration,
                    _entity,
                    _prototype);

                button.OnPreferenceChanged += p => OnButtonPreferenceChanged(button, p);
                button.OnCustomizeToggled += _ => OnCustomizeToggled?.Invoke(button.Preference);
                button.OnOpenGuidebook += args => OnOpenGuidebook?.Invoke(args);

                listBox.AddChild(button);
                _loadoutButtons.Add(loadout, button);
            }
        }
    }

    private BoxContainer CreateLoadoutListBox(ProtoId<LoadoutCategoryPrototype> categoryId)
    {
        var listBox = new BoxContainer()
        {
            Orientation = LayoutOrientation.Vertical,
            HorizontalExpand = true,
            HorizontalAlignment = HAlignment.Stretch,
            Name = "ItemCategory" + categoryId,
            Visible = false,
        };

        return listBox;
    }

    private void UpdateSearchFilter(string filter)
    {
        filter = filter.ToLowerInvariant();

        foreach (var (loadout, button) in _loadoutButtons)
        {
            var id = loadout.ID.ToLowerInvariant();
            var name = button.LoadoutName.ToLowerInvariant();
            var match = string.IsNullOrWhiteSpace(filter)
                || id.Contains(filter)
                || name.Contains(filter);

            button.MatchFilter = match;
            UpdateButtonVisible(button);
        }
    }

    private void UpdatePreferences()
    {
        var profilePrefs = _profile?.LoadoutPreferences ?? new();
        var selectedButtons = _loadoutButtons.Values
            .Where(b => b.Pressed);

        foreach (var button in selectedButtons)
        {
            if (!_profilePreferenceLookup.TryGetValue(button.Loadout.ID, out var _))
                button.SetSelected(false);
        }

        foreach (var pref in profilePrefs)
        {
            if (pref != null
                && _prototype.TryIndex<LoadoutPrototype>(pref.LoadoutName, out var loadout)
                && _loadoutButtons.TryGetValue(loadout, out var button))
                button.Preference = pref;
        }
    }

    private void UpdateButtonVisibility()
    {
        foreach (var button in _loadoutButtons.Values)
            UpdateButtonVisible(button);
    }

    private void UpdateButtonVisible(LoadoutItemButton button)
    {
        button.Visible = button.MatchFilter &&
            (ShowUnusableButton.Pressed || !(button.Unusable || button.Unwearable));
    }

    private void UpdateRequirements()
    {
        if (_profile == null)
            return;

        foreach (var button in _loadoutButtons.Values)
        {
            UpdateButtonRequirements(button);
            UpdateButtonWearable(button);
            UpdateButtonVisible(button);
        }
    }

    private void UpdateButtonRequirements(LoadoutItemButton button)
    {
        if (_profile == null)
            return;

        var loadout = button.Loadout;
        var context = _characterRequirements.GetProfileContext(_profile).WithPrototype(loadout);
        var isValid = _characterRequirements.CheckRequirementsValid(requirements: loadout.Requirements,
            context: context,
            entityManager: _entity,
            prototypeManager: _prototype,
            configManager: _configuration);

        if (button.Unusable == !isValid)
            return;

        button.SetUnusable(!isValid);
    }

    private void UpdateButtonWearable(LoadoutItemButton button)
    {
        var wearable = true;

        if (_characterDummy == null
            || button.PreviewEntity == null
            || _entity.HasComponent<ClothingComponent>(button.PreviewEntity.Value)
            && !_characterRequirements.CanEntityWearItem(_characterDummy.Value, button.PreviewEntity.Value))
            wearable = false;

        if (button.Unwearable == !wearable)
            return;

        button.SetUnwearable(!wearable);
    }

    private void RemoveUnusableLoadouts()
    {
        if (!AdminUIHelpers.TryConfirm(RemoveUnusableButton, _confirmationData))
            return;

        OnRemoveUnusableLoadouts?.Invoke();
    }

    private void OnButtonPreferenceChanged(LoadoutItemButton button, LoadoutPreference preference)
    {
        var loadout = button.Loadout;
        var currSelected = _profilePreferenceLookup.TryGetValue(preference.LoadoutName, out _);
        var newSelected = button.Pressed;

        // We're changing the selected state of the button.
        if (currSelected != newSelected)
        {
            var shouldSelect = ValidateSelection(loadout, newSelected);
            if (shouldSelect != newSelected)
            {
                button.SetSelected(shouldSelect);

                // If newSelected != currSelected AND newSelected != shouldSelect,
                // then currSelected == shouldSelect. This means that our preference selection status
                // ultimately did not change. This is why we're returning here.
                return;
            }
        }

        OnPreferenceChanged?.Invoke(preference);
    }

    private void RecalculatePoints()
    {
        _points = MaxPoints;

        if (_profile?.LoadoutPreferences != null)
        {
            _points -= _profile.LoadoutPreferences
                .Where(p => p.Selected)
                .Select(p => _prototype.Index<LoadoutPrototype>(p.LoadoutName))
                .Sum(l => l.Cost);
        }

        OnPointsUpdaated?.Invoke(_points);
    }

    private bool ValidateSelection(LoadoutPrototype loadout, bool attemptSelected)
    {
        var cost = loadout.Cost;

        // If we're trying to select it; allow selection if the new point value would not be negative.
        // (I.e: Has enough points to select)
        if (attemptSelected)
            return _points - cost >= 0;

        // If we're trying to deselect it; force selection if the new point value would be negative.
        // (I.e: Has enough points to deselect)
        // ...Shouldn't happen unless you're making loadouts with negative point costs for some reason.
        return _points + cost < 0;
    }

    public EntityUid? GetPreviewEntity(LoadoutPrototype loadout)
    {
        if (_loadoutButtons.TryGetValue(loadout, out var button))
            return button.PreviewEntity;

        return null;
    }
}
